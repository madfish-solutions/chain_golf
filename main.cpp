#define AS AbstractServer
#define ASC AbstractServerConnector
#define bM bindAndAddMethod
#define sVt serverVersion_t
#define JS JSON_STRING
#define V virtual
#define U using namespace
#define u64 unsigned long long
#define u8 unsigned char
#include<cstdio>
#include<filesystem>
#include<iostream>
#include<thread>
#include<jsonrpccpp/server.h>
#include<jsonrpccpp/server/connectors/httpserver.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define ROTL64(x, y) (((x)<<(y))|((x)>>(64-(y))))
typedef struct{int b,l,w,nr;}keccak_t;void compute_rho(int w);int keccakf(int,u64*);int keccak(int r,int c,int n,int l,u8* M,u8* O);int sha3_512(u8* M,int l,u8* O);int sha3_384(u8* M,int l,u8* O);int sha3_256(u8* M,int l,u8* O);int sha3_224(u8* M,int l,u8* O);const u64 RC[24]={0x0000000000000001,0x0000000000008082,0x800000000000808a,0x8000000080008000,0x000000000000808b,0x0000000080000001,0x8000000080008081,0x8000000000008009,0x000000000000008a,0x0000000000000088,0x0000000080008009,0x000000008000000a,0x000000008000808b,0x800000000000008b,0x8000000000008089,0x8000000000008003,0x8000000000008002,0x8000000000000080,0x000000000000800a,0x800000008000000a,0x8000000080008081,0x8000000000008080,0x0000000080000001,0x8000000080008008};const int rx[25]={0,1,62,28,27,36,44,6,55,20,3,10,43,25,39,41,45,15,21,8,18,2,61,56,14};keccak_t perms[7]={{25,0,1,12},{50,1,2,14},{100,2,4,16},{200,3,8,18},{400,4,16,20},{800,5,32,22},{1600,6,64,24},};void compute_rho(int w){int rho[25];rho[0]=0;uint32_t x,y,z;x=1;y=0;uint32_t t,n;for(t=0;t < 24;++t){n=((t + 1)*(t + 2)/ 2)% w;rho[y * 5 + x]=n;z=(0 * x + 1 * y)% 5;y=(2 * x + 3 * y)% 5;x=z;}}void theta(u64* state){u64 C[5]={0,0,0,0,0};u64 D[5]={0,0,0,0,0};int x,y;for(x=0;x < 5;++x){C[x]=state[x] ^ state[5 + x] ^ state[10 + x] ^ state[15 + x] ^ state[20 + x];}for(x=0;x < 5;++x){D[x]=C[(x + 4)% 5] ^ ROTL64(C[(x + 1)% 5],1);for(y=0;y < 5;++y){state[y * 5 + x]=state[y * 5 + x] ^ D[x];}}}void rho(u64* state){int x,y;for(y=0;y < 5;++y){for(x=0;x < 5;++x){state[y * 5 + x]=ROTL64(state[y * 5 + x],rx[y * 5 + x]);}}}void pi(u64* state){u64 B[25];int x,y;for(y=0;y < 5;++y){for(x=0;x < 5;++x){B[y * 5 + x]=state[5 * y + x];}}int u,v;for(y=0;y < 5;++y){for(x=0;x < 5;++x){u=(0 * x + 1 * y)% 5;v=(2 * x + 3 * y)% 5;state[v * 5 + u]=B[5 * y + x];}}}void chi(u64* state){u64 C[5];int x,y;for(y=0;y < 5;++y){for(x=0;x < 5;++x){C[x]=state[y * 5 + x] ^((~state[y * 5 +((x + 1)% 5)])& state[y * 5 +((x + 2)% 5)]);}for(x=0;x < 5;++x){state[y * 5 + x]=C[x];}}}void iota(u64* state,int i){state[0]=state[0] ^ RC[i];}int keccakf(int rounds,u64* state){int i;for(i=0;i < rounds;++i){theta(state);rho(state);pi(state);chi(state);iota(state,i);}return 0;}void sponge_absorb(int nr,int r,int w,int l,u64* A,u8* P){int x,y;int blocks=l /(r / 8);for(y=0;y < blocks;++y){u64* block=(u64*)P + y * r/w;for(x=0;x <(r/w);++x){A[x]=A[x] ^ block[x];}keccakf(nr,A);}}void sponge_squeeze(int nr,int r,int n,u64* A,u8* O){int i=0;while(n){size_t size=r;if(r > n){size=n;}memcpy(&O[i],A,size/8);i=i + size/8;n=n - size;if(n > 0){keccakf(nr,A);}}}int pad101(int r,int blocks,int l,u8* M,u8* P){int block_size=r/8;size_t block_len=(blocks + 1)* block_size;memset(P,0,block_len * sizeof(u8));int i;for(i=0;i < l;++i){P[i]=M[i];}P[l]=0x01;P[block_len - 1]=0x80;if(l % block_size==0){return l;}return block_len;}int keccak(int r,int c,int n,int l,u8* M,u8* O){if(r < 0 ||(r % 8 !=0)){return -1;}if(n % 8 !=0){return -2;}int b=r + c;int i,j=-1;for(i=0;i < 7;++i){if(b==perms[i].b){j=i;break;}}if(j==-1){return -3;}u64 A[25];memset(A,0,25 * sizeof(u64));int w=perms[j].w;int nr=perms[j].nr;int block_size=r/8;int blocks=l / block_size;u8* P=new u8(block_size *(blocks + 1));l=pad101(r,blocks,l,M,P);sponge_absorb(nr,r,w,l,A,P);sponge_squeeze(nr,r,n,A,O);free(P);return 0;}int sha3_512(u8* M,int l,u8* O){return keccak(576,1024,512,l,M,O);}int sha3_384(u8* M,int l,u8* O){return keccak(832,768,384,l,M,O);}int sha3_256(u8* M,int l,u8* O){return keccak(1088,512,256,l,M,O);}int sha3_224(u8* M,int l,u8* O){return keccak(1152,448,224,l,M,O);}U std;U jsonrpc;U Json;class TS:public AS<TS>{public:TS(ASC &c,sVt type=JSONRPC_SERVER_V2):AS<TS>(c,type){bM(Procedure("balance",PARAMS_BY_NAME,JSON_INTEGER,"address",JS,0),&TS::B);bM(Procedure("transaction",PARAMS_BY_NAME,JS,"amount",JSON_INTEGER,"from_address",JS,"to_address",JS,0),&TS::tx);}V void B(const Value &rq,Value &rs){rs=B(rq["address"].asString());}V void tx(const Value &rq,Value &rs){rs=tx(rq["amount"].asInt(),rq["from_address"].asString(),rq["to_address"].asString());}V int B(const string &A)=0;V string tx(int amount,const string &fA,const string &tA)=0;};class MS:public TS{public:MS(ASC &c,sVt type);int B(const string &A)override;string tx(int amount,const string &fA,const string &tA)override;};MS::MS(ASC &c,sVt type):TS(c,type){}int MS::B(const string &A){cout<<"SERVER | Received in balance: address["<<A<<"]"<<endl;return 1;}string MS::tx(int amount,const string &fA,const string &tA){cout<<"SERVER | Received in transaction: from_address["<<fA<<"], to_address["<<tA<<"], amount["<<amount<<"]"<<endl;return "transaction block hash";}int main(){HttpServer hs(10001);MS s(hs,JSONRPC_SERVER_V1V2);s.StartListening();cout<<"welcome to UTON HACK!"<<endl;this_thread::sleep_for(chrono::seconds(45));s.StopListening();return 0;}